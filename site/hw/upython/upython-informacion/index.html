<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Micropython - Tips de Cristo</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Micropython", url: "#_top", children: [
              {title: "Preparar placa ESP8266 con Micropython", url: "#preparar-placa-esp8266-con-micropython" },
              {title: "Preparar placa ESP32 con Micropython", url: "#preparar-placa-esp32-con-micropython" },
              {title: "Acceso a la placa + REPL", url: "#acceso-a-la-placa-repl" },
              {title: "Primeros pasos", url: "#primeros-pasos" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h1 id="micropython">Micropython</h1>
<p>La información oficial de Micropython está en su web -&gt; <a href="http://docs.micropython.org/en/latest/index.html">Documentación Oficial</a>  </p>
<h2 id="preparar-placa-esp8266-con-micropython">Preparar placa ESP8266 con Micropython</h2>
<p>Enlaces de ayuda:</p>
<ul>
<li>El tutorial oficial (en inglés) está -&gt; <a href="http://docs.micropython.org/en/latest/esp8266/tutorial/intro.html">aquí</a>.</li>
<li>Se recomienda el tutorial en español de Python Canarias -&gt; <a href="https://github.com/pythoncanarias/upython#pasos-previos">aquí</a>.</li>
</ul>
<p>Para instalar micropython en nuestra placa hay que seguir los siguientes pasos:</p>
<ol>
<li><strong>Instalar</strong> <code>esptool</code> en Python (se recomienda usar un virtualenv).</li>
</ol>
<p><code>bash
   pip install esptool</code></p>
<p>Con el comando <code>esptool.py --help</code> podemos ver todas las opciones.
   <strong>NOTA</strong>: Si estas en <strong>Windows</strong> o <strong>Mac</strong>, tienes que <strong>instalar</strong> los <strong>drivers</strong> del chip <strong>CH340</strong> / <strong>CH341</strong> (son los que permiten la comunicación por el USB).</p>
<ul>
<li>Windows -&gt; <a href="http://www.wch.cn/download/CH341SER_EXE.html">aquí</a></li>
<li>
<p>Mac -&gt; <a href="http://www.mblock.cc/docs/run-makeblock-ch340-ch341-on-mac-os-sierra/">aquí</a></p>
</li>
<li>
<p><strong>Descargar</strong> el <strong>firmware</strong> (se recomienda el último estable) -&gt; <a href="http://micropython.org/download#esp8266">aquí</a>.</p>
</li>
<li><strong>Conectar</strong> la <strong>placa</strong> por el <strong>USB</strong> y <strong>descubrir</strong> en que <strong>puerto</strong> está conectada.</li>
<li><strong>Borrar</strong> la <strong>flash</strong> de la placa con el comando</li>
</ul>
<p><code>bash
   esptool.py --port &lt;puerto&gt; erase_flash</code></p>
<p>Por ejemplo  </p>
<p><code>bash
   esptool.py --port /dev/ttyUSB0 erase_flash</code></p>
<ol>
<li><strong>Flashear</strong> la <strong>placa</strong> con el <strong>firmware</strong></li>
</ol>
<p><code>bash
   esptool.py --port &lt;port&gt; --baud &lt;baudios&gt; write_flash --flash_size=detect 0 &lt;fichero-de-firmware&gt;</code></p>
<p>Por ejemplo  </p>
<p><code>bash
   esptool.py --port /dev/ttyUSB0 --baud 115200 write_flash --flash_size=detect 0 esp8266-20190125-v1.10.bin</code></p>
<p>En algunas placas es probable que dé error y haya que añadir la opción <code>-fm dio</code>, ejemplo  </p>
<p><code>bash
   esptool.py --port /dev/ttyUSB0 --baud 115200 write_flash --flash_size=detect -fm dio 0 esp8266-20190125-v1.10.bin</code></p>
<h2 id="preparar-placa-esp32-con-micropython">Preparar placa ESP32 con Micropython</h2>
<p>Enlaces de ayuda:</p>
<ul>
<li>El tutorial oficial (en inglés) -&gt; <a href="http://docs.micropython.org/en/latest/esp32/tutorial/intro.html">aquí</a>.</li>
<li>Tutorial español de <a href="https://github.com/zerasul">Zerasul</a> -&gt; <a href="https://github.com/zerasul/upython-book/blob/master/instalacion.md">aquí</a>.</li>
</ul>
<p>Para instalar micropython en nuestra placa hay que seguir los siguientes pasos:</p>
<ol>
<li><strong>Instalar</strong> <code>esptool</code> en Python (se recomienda usar un virtualenv).</li>
</ol>
<p><code>bash
   pip install esptool</code></p>
<p>Con el comando <code>esptool.py --help</code> podemos ver todas las opciones.</p>
<ol>
<li><strong>Descargar</strong> el <strong>firmware</strong> (se recomienda el último estable) -&gt; <a href="http://micropython.org/download#esp32">aquí</a>.</li>
<li><strong>Conectar</strong> la <strong>placa</strong> por el <strong>USB</strong> y descubrir en que <strong>puerto</strong> está conectada.</li>
<li><strong>Borrar</strong> la <strong>flash</strong> de la placa con el comando</li>
</ol>
<p><code>bash
   esptool.py --port &lt;puerto&gt; erase_flash</code></p>
<p>Por ejemplo</p>
<p><code>bash
   esptool.py --port /dev/ttyUSB0 erase_flash</code></p>
<ol>
<li><strong>Flashear</strong> la <strong>placa</strong> con el <strong>firmware</strong></li>
</ol>
<p><code>bash
   esptool.py --chip esp32 --port &lt;port&gt; --baud &lt;baudios&gt; write_flash -z 0x1000 &lt;fichero-de-firmware&gt;</code></p>
<p>Por ejemplo</p>
<p><code>bash
   esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 115200 write_flash -z 0x1000 esp32-20190125-v1.10.bin</code></p>
<p>En algunas placas es probable que dé error y haya que añadir la opción <code>-fm dio</code>, ejemplo</p>
<p><code>bash
   esptool.py --chip esp32 --port /dev/ttyUSB0 write_flash --baud 115200 -z 0x1000 -fm dio esp32-20190125-v1.10.bin</code></p>
<h2 id="acceso-a-la-placa-repl">Acceso a la placa + REPL</h2>
<p>A la placa se puede acceder por dos medios:</p>
<ul>
<li>Serial</li>
<li>Web</li>
</ul>
<p>Una vez se accede a la placa, estamos en el <a href="https://es.wikipedia.org/wiki/REPL">REPL</a> (Read-Eval-Print-Loop) de esta. A efectos prácticos es un interprete de Python y además cuenta con autocompletado. Para ver todas las opciones con las que cuenta escribimos</p>
<pre><code class="python">help()
</code></pre>

<p>Veremos todos los comandos y una pequeña ayuda. Los comandos más importantes son:</p>
<ul>
<li><code>Barra espaciadora</code> -&gt; Sirve para el autocompletado.</li>
<li><code>Ctrl+C</code> -&gt; Para cerrar algún script que hayamos abierto dentro de la placa.</li>
<li><code>Ctrl+D</code> -&gt; Para hacer un reset por software (soft reset).</li>
<li><code>Ctrl+E</code> -&gt; Modo pegar (de copia-pega).</li>
</ul>
<p>También podremos usar esta función para ver con que variables/constantes + funciones cuenta cada módulo. Por ejemplo importamos el módulo <code>esp</code> y vemos todo lo que tiene</p>
<pre><code class="python">import esp

help(esp)
</code></pre>

<p>Para ver todos los módulos disponibles en la placa se hace</p>
<pre><code class="python">help('modules')
</code></pre>

<h3 id="comunicacion-con-la-placa-por-serial-serialrepl">Comunicación con la placa por serial -&gt; SerialREPL</h3>
<p>Para poder entrar dentro de la placa, estas normalmente traen una UART (interfaz serie, como un USB dentro) accesible por los pines TX y RX. Así que con el cable usb y un programa que permita conexión serial podemos acceder a la placa. Programas con serial hay muchos, tanto con interfaz gráfica (GUI) como por terminal:</p>
<ul>
<li>Windows</li>
<li><a href="https://mobaxterm.mobatek.net/">MobaXterm</a></li>
<li><a href="https://www.putty.org/">PuTTY</a></li>
<li><a href="http://freeware.the-meiers.org/">CoolTerm</a></li>
<li>Mac</li>
<li><a href="http://freeware.the-meiers.org/">CoolTerm</a></li>
<li><a href="https://ss64.com/osx/screen.html">Screen</a></li>
<li>Linux</li>
<li><a href="https://www.putty.org/">PuTTY</a></li>
<li><a href="http://gtkterm.feige.net/">GTKTerm</a></li>
<li><a href="https://www.gnu.org/software/screen/">GNU screen</a></li>
<li><a href="https://github.com/npat-efault/picocom">Picocom</a></li>
<li><a href="http://freeware.the-meiers.org/">CoolTerm</a></li>
</ul>
<h3 id="comunicacion-con-la-placa-por-wifi-webrepl">Comunicación con la placa por WiFi -&gt; WebREPL</h3>
<p>También se puede acceder al REPL de la placa a través de una utilidad web, WebREPL, pero para ello debemos seguir los siguientes pasos:</p>
<ol>
<li>Abrir la utilidad <a href="http://micropython.org/webrepl/">WebREPL</a> en un navegador web.</li>
<li>Acceder a la placa por serial.</li>
<li>Configurar la WiFi en modo AP (Punto de Acceso). Se adjunta pequeño script de ayuda</li>
</ol>
<p><code>python
    import network
    # Primero activamos el interfaz AP de la placa
    my_wifi = 'nombre-para-la-wifi'
    my_password = 'contraseña-para-la-wifi' # Debe tener al menos 8 caracteres
    ap_lan = network.WLAN(network.AP_IF)
    ap_lan.active(True) # Devuelte True si la interfaz AP está activa
    ap_lan.config(essid=my_wifi, password=my_password)
    # Despues activamos el webrepl
    import webrepl_setup</code></p>
<ol>
<li>Después debemos configurar el WebREPL con</li>
</ol>
<p><code>python
   import webrepl_setup</code></p>
<p>Nos saldran las instrucciones para activar el WebREPL (activarlo), hay que ponerle una contraseña de entre 4-9 caracteres y por último reiniciarlo.</p>
<ol>
<li>Conectarse a la WiFi de la placa.</li>
<li>Ir a la web de WebREPL que está abierta en el navegador y darle al botón <strong><em>Connect</em></strong> (pedirá el password puesto en el paso 4.).</li>
</ol>
<h2 id="primeros-pasos">Primeros pasos</h2>
<h3 id="filesystem-y-sistema-de-ejecucion">Filesystem y sistema de ejecución</h3>
<p>Cuando la placa arranca, se ejecuta un fichero interno, <code>_boot.py</code>, que monta todo el sistema de ficheros (filesystem). Una vez el sistema está montado, se ejecutan dos ficheros secuencialmente (si existen):</p>
<ol>
<li><code>boot.py</code> -&gt; Equivale al <code>setup()</code> de Arduino.</li>
<li><code>main.py</code> -&gt; Equivale al <code>loop()</code> de Arduino.</li>
</ol>
<h3 id="configurar-wifi">Configurar WiFi</h3>
<p>Las placas ESPx cuentan con dos interfaces de red:</p>
<ul>
<li>Station Interface -&gt; Es para conectarse a una red WiFi.</li>
<li>Access Point Interface -&gt; Es para crear una red WiFi propia.</li>
</ul>
<p>Las dos interfaces pueden funcionar a la vez, es decir, que estar conectada la placa a una red WiFi y a la vez generar su propia red WiFi. Para poder configurarlos necesitamos trabajar con el módulo <code>network</code>.</p>
<ul>
<li>Conectarse a una red WiFi:</li>
</ul>
<p>```python
  import network</p>
<p>red = 'nombre-de-la-red-wifi'
  contrasena = 'pass-de-la-wifi'</p>
<p>sta_if = network.WLAN(network.STA_IF)
  sta_if.active(True)
  sta_if.connect(red, contrasena)
  ```</p>
<ul>
<li>Crear una red WiFi:</li>
</ul>
<p>```python
  import network</p>
<p>red = 'nombre-para-la-wifi'
  contrasena = 'contrasena-para-la-wifi'</p>
<p>ap_if = network.WLAN(network.AP_IF)
  ap_if.active(True)
  ap_if.config(red, contrasena)
  ```</p>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>