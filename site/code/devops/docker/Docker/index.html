<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Docker - Tips de Cristo</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Docker", url: "#_top", children: [
              {title: "Instalaci\u00f3n", url: "#instalacion" },
              {title: "Docker Hub", url: "#docker-hub" },
              {title: "Comandos para trabajar con Docker", url: "#comandos-para-trabajar-con-docker" },
              {title: "Dockerfile -&gt; Crear imagen desde cero", url: "#dockerfile-crear-imagen-desde-cero" },
              {title: "Docker Volumes", url: "#docker-volumes" },
              {title: "Docker Network", url: "#docker-network" },
              {title: "Docker Compose", url: "#docker-compose" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h1 id="docker">Docker</h1>
<p>Importante aclarar:</p>
<ul>
<li>Docker Host o solo Host -&gt; Es la máquina donde se van a ejecutar los contenedores.</li>
<li>Docker Container o solo Contenedor -&gt; Lo que entendemos por contenedor.</li>
<li>Docker Image o solo Imagen -&gt; Es el modelo sobre el que se basa el contenedor.</li>
<li>Si un contenedor equivale a una VM (máquina virtual).</li>
<li>Entonces una imagen equivale a la iso del SO que usamos para crear la VM.</li>
</ul>
<h2 id="instalacion">Instalación</h2>
<p>En este <a href="https://get.docker.com/">enlace</a> está el script para instalar docker. En consola haríamos  </p>
<pre><code class="bash">curl -fsSL https://get.docker.com -o get-docker.sh &amp;&amp; sh get-docker.sh -y
</code></pre>

<p>Después de instalarlo deberemos darle los permisos al usuario docker para no tener que usarlo como root</p>
<pre><code class="bash">sudo usermod -aG docker $USER
</code></pre>

<p>Ahora hay que cerrar sesión / logout / reiniciar, y volver a entrar para que los cambios surtan efecto. Una vez hecho esto podemos comprobar que todo funciona correctamente con los siguientes comandos (probarlos todos):</p>
<ul>
<li><code>docker -v</code> -&gt; Versión instalada en formato corto.</li>
<li><code>docker version</code> -&gt; Versión instalada en formato extendido.</li>
<li><code>docker info</code> -&gt; Información detallada del sistema.</li>
<li><code>docker</code> -&gt; Lista todos los comandos de docker.</li>
</ul>
<h2 id="docker-hub">Docker Hub</h2>
<p>Lo primero que se recomienda es hacerse una cuenta en <a href="https://hub.docker.com/">Docker Hub</a>. Esta es una plataforma donde se suben y donde poder ir subiendo, imágenes docker.</p>
<h2 id="comandos-para-trabajar-con-docker">Comandos para trabajar con Docker</h2>
<h3 id="docker-search-buscar-imagenes">docker search -&gt; Buscar imágenes</h3>
<p>Una vez hecha la cuenta, podemos buscar imágenes tanto desde la web, como desde la terminal con el comando <code>docker search</code>. Por ejemplo si quiero buscar una imagen de Ubuntu por ejemplo haría  </p>
<pre><code class="bash">docker search ubuntu
</code></pre>

<p>Y veremos la cantidad de imágenes disponibles de ubuntu que se han creado, oficiales o no, y cuantas estrellas / likes tienen. Si solo quisieramos ver por ejemplo las imagenes de ubuntu que sean de 14.04, haríamos</p>
<pre><code class="bash">docker search ubuntu:14.04
</code></pre>

<h3 id="docker-pull-descargar-imagenes">docker pull -&gt; Descargar imágenes</h3>
<p>Para poder descargar una imagen basta con poner <code>docker pull &lt;nombre-de-la-imagen&gt;</code>. Por ejemplo si queremos descargar la ubuntu oficial haríamos</p>
<pre><code class="bash">docker pull ubuntu
</code></pre>

<p>Pero si por ejemplo nos interesa más la ubuntu de pivotaldata, es tan sencillo como</p>
<pre><code class="bash">docker pull pivotaldata/ubuntu
</code></pre>

<h3 id="docker-images-ver-imagenes-descargadas-en-el-sistema">docker images -&gt; Ver imágenes descargadas en el sistema</h3>
<p>Con este comando podemos ver todas las imagenes que se han descargado en el sistema. <strong>OJO</strong>, imagén es distinto de contenedor, podemos tener varios contenedores de la misma imagen.</p>
<pre><code class="bash">docker images
</code></pre>

<p>Veremos como después de descargar la imagen, la ejecuta y obtenemos un mensaje por pantalla generado por el contenedor.</p>
<h3 id="docker-ps-ver-los-contenedores-ejecutandose-ejecutados">docker ps -&gt; Ver los contenedores ejecutándose / ejecutados</h3>
<p>Para poder ver los contenedores ejecutándose hacemos</p>
<pre><code class="bash">docker ps
</code></pre>

<p>Si en cambio queremos ver los que se han ejecutado</p>
<pre><code class="bash">docker ps -a
</code></pre>

<p>Más info con el comando <code>docker ps --help</code></p>
<h3 id="docker-run-lanzar-contenedores">docker run -&gt; Lanzar contenedores</h3>
<p>Para lanzar un contenedor basta con usar (tanto las opciones como los comandos son opcionales)</p>
<pre><code class="bash">docker run [&lt;opciones&gt;] &lt;contenedor&gt; [&lt;comandos&gt;]
</code></pre>

<p>Más info -&gt; <code>docker run --help</code>.</p>
<h4 id="hello-world">Hello World</h4>
<p>Para hacer un <strong><em>Hola mundo</em></strong> en Docker, lo que se hace es ejecutar un contenedor de la imagen <strong>hello-world</strong>. Para ello podemos bajar la imagen con <code>docker pull hello-world</code> y luego ejecutarlo. O bien ejecutarlo directamente y ya docker se encarga de bajar la imagen si n está y ejecutarla. Para ello hacemos</p>
<pre><code class="bash">docker run hello-world
</code></pre>

<h4 id="puertos">Puertos</h4>
<p>Por defecto todos los contenedores tienen todos los puertos cerrados. En muchos casos tienen ciertos puertos para poder consumir un servicio y el propio contenedor te dice que puertos y que tráfico soportan. La gracia aquí está en que nosotros podemos asignarle cualquier puerto del Host a ese puerto del contenedor con la opción <code>-p &lt;puerto-host&gt;:&lt;puerto-contenedor&gt;</code>. En el ejemplo ejecuto un docker con un jenkins, y le asígno el puerto 80 de mi máquina (que es el que usan los navegadores) al puerto 8080 del contenedor (que es por donde se despacha el jenkins).</p>
<pre><code class="bash">docker run -p 80:8080 jenkins
</code></pre>

<p>Esto es un buena solución en cuestiones de seguridad y de escalabilidad, ya que el contenedor tiene los puertos por defecto pero el host no.</p>
<h4 id="lanzar-contenedor-con-comando">Lanzar contenedor con comando</h4>
<p>Para ver por ejemplo el filesystem del contenedor ubuntu hacemos <code>docker run ubuntu ls</code>.  </p>
<h4 id="contenedores-interactivos">Contenedores interactivos</h4>
<p>Para que el contenedor ubuntu no se pare por ejemplo, podemos acceder con la opción <strong>interactive</strong> y con <strong>tty</strong></p>
<pre><code class="bash">docker run -i -t ubuntu bash
</code></pre>

<p>Ahora estamos dentro del container y podemos ejecutar comandos o lo que queramos.</p>
<h4 id="asignarle-un-nombre-al-contenedor">Asignarle un nombre al contenedor</h4>
<p>Para asignarle un nombre al contenedor para ser usado de manera más cómoda, hay que usar la opción <code>--name</code>. Este nombre se podrá usar en sustitución del <strong>id</strong> del contenedor en muchos comandos, haciendo así más fácil su uso.</p>
<pre><code class="bash">docker run --name perico -it ubuntu
</code></pre>

<p>Si queremos renombrar un contenedor debemos usar el comando <code>docker rename</code>.</p>
<pre><code class="bash">docker rename &lt;nombre-actual-del-contenedor&gt; &lt;nuevo-nombre-del-contenedor&gt;
</code></pre>

<h4 id="salir-del-contenedor">Salir del contenedor</h4>
<ul>
<li>Salir del contenedor y apagarlo / matarlo:</li>
<li>Para salir del contenedor podemos ejecutar el comando <code>exit</code></li>
<li>Usar la combinación <strong><em>Ctrl+D</em></strong>.</li>
<li>Salir del contenedor pero mantenerlo activo:</li>
<li>Mantener todo el rato la tecla <strong><em>Ctrl</em></strong></li>
<li>Luego pulsar <strong><em>P</em></strong></li>
<li>Después <strong><em>Q</em></strong></li>
<li>Es decir -&gt; <strong><em>Ctrl+P</em></strong>, <strong><em>D</em></strong></li>
</ul>
<h4 id="limitar-recursos">Limitar recursos</h4>
<p>Ejemplo, limitar memoria a 500MB y solo usar hasta 2 cores</p>
<pre><code class="bash">docker run -m &quot;500mb&quot; --cpu-set-cpus 0-1 &lt;imagen&gt;
</code></pre>

<h3 id="docker-start-restart-arrancar-un-contenedor-parado">docker start / restart -&gt; Arrancar un contenedor parado</h3>
<p>Con <code>docker ps -a</code> podemos ver los contenedores que ya no están activos (<code>STATUS = Exited</code>). Si queremos volver a la lanzar uno, debemos de copiar su id (podemos usar el <strong>name</strong> del contenedor en lugar de su id) y ejecutar</p>
<pre><code class="bash">docker start &lt;id-contenedor&gt;
</code></pre>

<p>También existe el comando <code>docker restart</code></p>
<h3 id="docker-attach-entrar-en-un-contenedor-activo">docker attach -&gt; Entrar en un contenedor activo</h3>
<p>Para poder entrar dentro de un contenedor que se está ejecutando debemos de tener su id y ejecutar</p>
<pre><code class="bash">docker attach &lt;id-contenedor&gt;
</code></pre>

<p>También podemos usar el <strong>name</strong> del contenedor en lugar de su id.</p>
<h3 id="docker-exec-ejecutar-comandos-en-un-contenedor-activo">docker exec -&gt; Ejecutar comandos en un contenedor activo</h3>
<p>Si queremos que dentro de un contenedor que ya se encuentra activo se ejecute algún comando se usa</p>
<pre><code class="bash">docker exec [&lt;opciones&gt;] &lt;id-o-name-contenedor&gt; &lt;comando&gt; [&lt;argumentos&gt;]
</code></pre>

<h3 id="docker-stop-parar-un-contenedor">docker stop -&gt; Parar un contenedor</h3>
<p>Para acabar con la ejecución de un contenedor usamos el comando</p>
<pre><code class="bash">docker stop &lt;id-o-nombre-del-contenedor&gt;
</code></pre>

<h3 id="docker-rm-rmi-borrar-contenedor-imagen">docker rm / rmi -&gt; Borrar contenedor / imagen</h3>
<p>Para borrar imagen</p>
<pre><code class="bash">docker rmi &lt;imagen&gt;
</code></pre>

<p>Para borrar contenedor hacemos</p>
<pre><code class="bash">docker rm &lt;id-o-name-del-contenedor&gt;
</code></pre>

<p>Si quisieramos que un contenedor se borrase una vez se dejara de ejecutar</p>
<pre><code class="bash">docker run --rm &lt;imagen&gt;
</code></pre>

<p>Más info -&gt; <code>docker rm --help</code> | <code>docker rmi --help</code></p>
<h3 id="docker-history-ver-el-historial-de-una-imagen">docker history -&gt; Ver el historial de una imagen</h3>
<p>Para poder ver todos los pasos que ha llevado a cabo hacer una imagen se usa</p>
<pre><code class="bash">docker history &lt;id-o-name-de-la-imagen&gt;
</code></pre>

<p>Se recomienda usar la opción <code>-H</code> para poder leerlo mejor</p>
<pre><code class="bash">docker history -H &lt;imagen&gt;
</code></pre>

<p>Más info -&gt; <code>docker history --help</code></p>
<h3 id="docker-logs-ver-los-logs-salidas-de-un-contenedor">docker logs -&gt; Ver los logs (salidas) de un contenedor</h3>
<pre><code class="bash">docker logs [&lt;opciones&gt;] &lt;contenedor&gt;
</code></pre>

<h3 id="docker-stats-ver-consumo-de-recursos-de-un-contenedor">docker stats -&gt; Ver consumo de recursos de un contenedor</h3>
<pre><code class="bash">docker stats [&lt;opciones&gt;] &lt;contenedor1&gt; &lt;contenedor2&gt; ...
</code></pre>

<h3 id="docker-cp-copiar-ficheros-a-desde-un-contenedor-activo">docker cp -&gt; Copiar ficheros a / desde un contenedor activo</h3>
<pre><code class="bash">docker cp [&lt;options&gt;] &lt;src-path&gt; &lt;contenedor&gt;:&lt;dest-path&gt;
docker cp [&lt;options&gt;] &lt;contenedor&gt;:&lt;src-path&gt; &lt;dest-path&gt;
</code></pre>

<h3 id="docker-inspect-obtener-informacion-de-bajo-nivel-de-un-contenedor">docker inspect -&gt; Obtener información de bajo nivel de un contenedor</h3>
<pre><code class="bash">docker inspect [&lt;opciones&gt;] &lt;contenedor&gt; [&lt;contenedor2&gt; &lt;contenedor3&gt; ...]
</code></pre>

<h3 id="docker-commit-crear-una-imagen-a-partir-de-un-contenedor-modificado">docker commit -&gt; Crear una imagen a partir de un contenedor (modificado)</h3>
<p>Supongamos que hemos abierto un contenedor, hemos modificado cosas y lo tenemos listo para trabajar. Si queremos crear una imagen así para poder usarla, lo que haríamos sería</p>
<pre><code class="bash">docker commit &lt;contenedor-modificado&gt; &lt;nombre-imagen-nueva&gt;
</code></pre>

<p>Podemos además ejecutar comandos previos al commit para crear la nueva imagen. Por ejemplo, supongamos una imagen de ubuntu que le hemos instalado el servidor Apache2 y hemos lanzado el servicio. Con</p>
<pre><code class="bash">docker commit --change='CMD [&quot;apache2ctl&quot;, &quot;-D FOREGROUND&quot;]' -c &quot;EXPOSE 85&quot; &lt;contenedor&gt; &lt;nombre-de-la-nueva-imagen&gt;
</code></pre>

<p>exponemos el puerto 85 del contenedor y tenemos el apache2 en primer plano.</p>
<p>Más info -&gt; <code>docker commit --help</code></p>
<h2 id="dockerfile-crear-imagen-desde-cero">Dockerfile -&gt; Crear imagen desde cero</h2>
<p>Info oficial -&gt; <a href="https://docs.docker.com/engine/reference/builder/">aquí</a></p>
<p>Para poder crear una imagen desde otra con todo lo que necesita, pero de manera más cómoda, lo que se usan son unos ficheros de texto llamados <code>Dockerfile</code>.</p>
<h3 id="estructura-directivas-del-dockerfile">Estructura / Directivas del Dockerfile</h3>
<p>Este fichero tiene ciertas palabras clave o directivas:</p>
<ul>
<li><code>FROM</code> -&gt; Imagen base en la que se va a basar la nueva.</li>
</ul>
<p><code>bash
  FROM &lt;image&gt; [AS &lt;name&gt;]
  FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]
  FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code></p>
<ul>
<li>Es la <strong>primera</strong> <strong>directiva</strong> del <code>Dockerfile</code>.</li>
<li>Puede haber varias <code>FROM</code> para usar lo que se llama el <strong><em>Multi-Stage-Build</em></strong>.</li>
<li>
<p>Puede ir precedida de la directiva <code>ARG</code></p>
<p>```bash
ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app</p>
<p>FROM extras:${CODE_VERSION}
CMD  /code/run-extras
```</p>
</li>
<li>
<p><code>LABEL</code> -&gt; Es para añadir metadata a la imagen (autor, mantenedor, versión, etc).</p>
</li>
</ul>
<p><code>bash
  LABEL &lt;key&gt;=value&lt;value&gt;
  LABEL &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></p>
<ul>
<li>Puede haber más de una <code>LABEL</code> por <code>Dockerfile</code>.</li>
<li>Consiste en un conjunto de clave-valor, y pueden ir varias por línea.</li>
<li><code>MAINTAINER</code> -&gt; Creador de la imagen, pero está deprecated. Usar <code>LABEL</code>.</li>
<li><code>RUN</code> -&gt; Comandos a ejecutar ANTES de ser creada (por ejemplo, paquetes a instalarle a la imagen base).</li>
</ul>
<p><code>bash
  RUN &lt;command&gt;
  RUN ["executable", "param1", "param2"]</code></p>
<ul>
<li>Puede haber varias directivas <code>RUN</code> en un <code>Dockerfile</code>.</li>
<li>Se debe usar comillas dobles <code>"</code> no comillas simples <code>'</code>.</li>
<li><code>COPY</code> -&gt; Copia ficheros locales a la imagen.</li>
</ul>
<p><code>bash
  COPY &lt;src&gt; &lt;dest&gt;
  COPY &lt;src1&gt; &lt;src2&gt; ... &lt;dest&gt;
  COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt; ... &lt;dest&gt;
  COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;", ... "&lt;dest&gt;"]</code></p>
<ul>
<li>Puede haber varios <code>COPY</code> por <code>Dockerfile</code>.</li>
<li><code>--chown</code> solo se puede usar en Linux (en Windows no).</li>
<li><code>ADD</code> -&gt; Hace lo mismo que <code>COPY</code>, pero además solo copia ficheros locales. Puedes copiar contenido desde una URL, o si el fichero está comprimido, al usar <code>ADD</code> lo descomprime.</li>
</ul>
<p><code>bash
  ADD &lt;src&gt; &lt;dest&gt;
  ADD &lt;src1&gt; &lt;src2&gt; ... &lt;dest&gt;
  ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt; ... &lt;dest&gt;
  ADD [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;", ... "&lt;dest&gt;"]</code></p>
<ul>
<li>Puede haber varios <code>ADD</code> en el <code>Dockerfile</code>.</li>
<li><code>--chown</code> solo sirve en Linux (en Windows no va).</li>
<li>Se pueden usar ciertas reglas en <code>&lt;src&gt;</code> y <code>&lt;dest&gt;</code> como <code>*.py</code> (todos los ficheros que acaben en <em>.py</em>).</li>
<li><code>ENV</code> -&gt; Variable de entorno.</li>
</ul>
<p><code>bash
  ENV key value
  ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></p>
<ul>
<li>Puede haber varias <code>ENV</code> por <code>Dockerfile</code>.</li>
<li>Si alguna <code>ENV</code> es igual que alguna <code>ARG</code>, la sobreescribe (<code>ENV</code> &gt; <code>ARG</code>).</li>
<li><code>WORKDIR</code> -&gt; Directorio de trabajo de la imagen.</li>
</ul>
<p><code>bash
  WORKDIR &lt;path&gt;</code></p>
<ul>
<li>Puede haber varios <code>WORKDIR</code> dentro del <code>Dockerfile</code> (aunque no tiene sentido).</li>
<li>Sirve para definir el directorio con las directivas <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code>, <code>ADD</code>.</li>
<li>
<p>Este ejemplo hace que el directorio de trabajo sea <code>/a/b/c</code></p>
<p><code>bash
WORKDIR /a
WORKDIR b
WORKDIR c</code></p>
<p>Que se podría poner de manera más simple con</p>
<p><code>bash
WORKDIR /a/b/c</code></p>
</li>
<li>
<p><code>EXPOSE</code> -&gt; Exponer por defecto un puerto del contenedor.</p>
</li>
</ul>
<p><code>bash
  EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt; ...]</code></p>
<ul>
<li>Puede haber varios <code>EXPOSE</code> por <code>Dockerfile</code>.</li>
<li>Si no se especifica el protocolo, por defecto toma <code>tcp</code>, pero si quieres <code>udp</code> tienes que especificarlo.</li>
<li>
<p>Si quisieras que permita los dos protocolos, se debe incluir en dos líneas.</p>
<p><code>bash
EXPOSE 80/tcp
EXPOSE 80/udp</code></p>
</li>
<li>
<p>Con la opción <code>-p</code> se sobreescribe lo del Dockerfile <code>docker run -p 80:80/tcp 80:80/udp ...</code>.</p>
</li>
<li>Esto se gestiona con <code>docker network</code>.</li>
<li><code>USER</code> -&gt; Sirve para indicar dentro del <code>Dockerfile</code> un usuario.</li>
</ul>
<p><code>bash
  USER &lt;user&gt;[:&lt;group&gt;]
  USER &lt;UID&gt;[:&lt;GID&gt;]</code></p>
<ul>
<li>Puede haber varios <code>USER</code> dentro del <code>Dockerfile</code>.</li>
<li>Son para ejecutar <code>RUN</code>, <code>CMD</code> o <code>ENTRYPOINT</code> con un usuario especifico, en lugar de root.</li>
<li>El usuario por defecto de un <code>Dockerfile</code> es root.</li>
<li><code>VOLUME</code> -&gt; Para persistencia de datos, indicamos al contenedor donde almacenar sus datos en un directorio del Docker Host (nuestra máquina).</li>
</ul>
<p><code>bash
  VOLUME ["/data"]</code></p>
<ul>
<li>Esto es un concepto más avanzado y se ve en su propia sección.</li>
<li>ENTRYPOINT -&gt;</li>
<li><code>CMD</code> -&gt; Acción por defecto al crear el contenedor.</li>
</ul>
<p><code>bash
  CMD ["executable", "param1", "param2"]
  CMD ["param1", "param2"]
  CMD command param1 param2</code></p>
<ul>
<li><strong>Solo</strong> puede haber <strong>una CMD por Dockerfile</strong>.</li>
</ul>
<h3 id="dockerignore-descartar-ficheros-para-crear-una-imagen">.dockerignore -&gt; Descartar ficheros para crear una imagen</h3>
<p>El <code>.dockerignore</code> equivale al <code>.gitignore</code> de git. Es un fichero donde indicarle al <code>Dockerfile</code> que archivos y/o directorios no cargar en la imagen.</p>
<h3 id="docker-build-construir-imagen-desde-el-dockerfile">docker build -&gt; Construir imagen desde el Dockerfile</h3>
<p>Por defecto el fichero se tiene que llamar <code>Dockerfile</code>, y para crear la imagen se hace</p>
<pre><code class="bash">docker build
</code></pre>

<p>Si queremos usar otro fichero con otro nombre como <code>Dockerfile</code> hay que usar la opción <code>-f</code></p>
<pre><code class="bash">docker build -f &lt;nombre-fichero-dockerfile&gt;
</code></pre>

<p>Se recomienda usar siempre la opción <code>-t</code> para asignarle un nombre y opcionalmente un tag a la imagen. Si no se especifica el tag, docker pone por defecto <code>latest</code></p>
<pre><code class="bash">docker build -t &lt;name&gt;[:&lt;tag&gt;]
</code></pre>

<p>Se le puede indicar el path donde está el <code>Dockerfile</code>, y este path puede ser incluso una url de un repo git. Se recomienda usar</p>
<pre><code class="bash">docker build -t &lt;nombre&gt;:&lt;tag&gt; &lt;path-absoluto-hasta-el-dockerfile&gt;
</code></pre>

<p>Más info:</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/build/">Oficial</a></li>
<li><code>docker build --help</code></li>
</ul>
<h3 id="imagenes-huerfanas-colgadas-dangling-images">Imágenes huérfanas / colgadas -&gt; Dangling images</h3>
<p>Si al construir varias imágenes del mismo <code>Dockerfile</code>, estas se llaman igual (porque no hemos especificado nombres y tags distintos), solo la más nueva tiene el nombre y todas las demás quedan huérfanas. Al usar <code>docker images</code> vemos come en su <code>REPOSITORY</code> pone <code>&lt;none&gt;</code> y en <code>TAG</code> pasa igual. Por eso <strong>HAY QUE USAR TAGS</strong>.</p>
<p>La forma de ver todas estas imágenenes colgadas es con</p>
<pre><code class="bash">docker images -f dangling=true
</code></pre>

<p>Lo lógico es borrar todas estas imágenes, para ello añadimos a la sentencia anterior <code>-q</code> para ver solo los ids y luego usar el comando <code>docker rmi</code>. Una forma automática de hacer esto es</p>
<pre><code class="bash">docker images -f dangling=true -q | xargs docker rmi
</code></pre>

<h3 id="multi-stage-build">Multi-Stage-Build</h3>
<p>Es probable que a veces necesitemos usar algo (fichero, carpetas, ...) de alguna imagen para poder usarlo en otra. Tendríamos dos opciones:</p>
<ol>
<li>Crear una imagen con "las dos imagenes dentro", es decir, crear una imagen más pesada.</li>
<li>Generar los recursos en una imagen temporal y copiarlos a la imagen final -&gt; Multi-Stage-Build.</li>
</ol>
<p>La forma de hacer el paso 2. consiste en usar varios <code>FROM</code> dentro del <code>Dockerfile</code>. A cada <code>FROM</code> se asigna un alias y para poder llamar algo de esa imagen usamos la opción <code>--from=&lt;alias&gt;</code>. El último <code>FROM</code> es con el que se va a construir la imagen, pero los anteriores los ejecuta y podemos copiar los ficheros en las instrucciones a partir del último <code>FROM</code>. Un ejemplo</p>
<pre><code class="bash">FROM &lt;imagen-que-genera-fichero&gt; AS &lt;alias-de-ayuda&gt;

# Operaciones

FROM &lt;imagen-final&gt;

COPY --from=&lt;alias-de-ayuda&gt; &lt;fichero-src-en-la-imagen-de-arriba&gt; &lt;fichero-dest-en-mi-imagen-final&gt;
</code></pre>

<p>La imagen base va a ser <code>&lt;imagen-final&gt;</code>, y todas las demás no entran dentro, pero si se generan para poder hacer el <code>COPY</code>.</p>
<h3 id="buenas-practicas-dockerfile">Buenas prácticas Dockerfile</h3>
<p>Info oficial -&gt; <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">aquí</a></p>
<ul>
<li>Contenedor efímero -&gt; Fácilmente destruible</li>
<li>Un servicio por contenedor</li>
<li>Crear un .dockerignore para evitar archivos pesados</li>
<li>Cuantas menos capas mejor:</li>
<li>Argumentos largos separados con <code>\</code>.</li>
<li>Varios argumentos en una sola capa (en vez de muchas capas).</li>
<li>No instalar paquetes innecesarios (solo el servicio).</li>
<li>Usar Multi-Stage-Build.</li>
<li>Usar <code>LABEL</code> para documentar (versiones, descripciones, etc).</li>
</ul>
<h2 id="docker-volumes">Docker Volumes</h2>
<p>Información oficial -&gt; <a href="https://docs.docker.com/storage/volumes/">aquí</a></p>
<p>Existen 3 tipos de volumenes:</p>
<ul>
<li>Host Volumes -&gt; Una carpeta del Host.</li>
<li>Named Volumes -&gt; Un volumen con nombre creado con Docker</li>
<li>No deja de ser un Host Volume pero en la carpeta <code>/../docker/volumes/&lt;nombre-volumen&gt;</code></li>
<li>Anonymous Volumes -&gt; Es igual que Named Volumes solo que el nombre es un hash que asigna docker.</li>
</ul>
<h3 id="manipular-crear-listar-destruir-volumenes-con-docker-volume">Manipular (crear, listar, destruir...) volumenes con <code>docker volume</code></h3>
<pre><code class="bash"># Crear volumen
docker volume create &lt;nombre-volumen&gt;
# Listar volumenes
docker volume ls
# Borrar volumen
docker volume rm &lt;nombre-volumen&gt;
</code></pre>

<p>Se recomienda asignar nombre a los volúmenes, ya que sino serán volúmenes anónimos y es más complicado nombrarlos (hay que usar su id).</p>
<h3 id="ejecutar-desde-el-docker-run">Ejecutar desde el <code>docker run</code></h3>
<pre><code class="bash"># Ejecutar contenedor con un volumen host montado en el contenedor
docker run -v [&lt;directorio-host-o-volumen-definido&gt;:]&lt;directorio-contenedor&gt; -t &lt;nombre-contenedor&gt;
# Borrar tanto el contendor como su volumen
docker rm -v &lt;nombre-contenedor&gt;
</code></pre>

<p>Si no indica el <code>&lt;directorio-host-o-volumen-definido&gt;</code>, se creará un volumen anónimo.  </p>
<h3 id="desde-el-dockerfile-podemos-hacer-lo-mismo-pero-solo-crea-volumenes-anonimos">Desde el <code>Dockerfile</code> podemos hacer lo mismo, pero solo crea volumenes anónimos</h3>
<pre><code class="bash">VOLUME &lt;directorio-contenedor&gt;
</code></pre>

<h3 id="dangling-volumes">Dangling Volumes</h3>
<p>Si al borrar los contenedores, no especificamos que borre sus volumenes con <code>-v</code>, quedarán los llamados <strong><em>Dangling Volumes</em></strong>. Para verlos y borrarlos</p>
<pre><code class="bash"># Ver todos los volumenes dangling
docker volume ls -f dangling=true
# Listar todos los ids de los dangling volumes | Borrarlos
docker volume ls -f dangling=true -q | xargs docker volume rm
</code></pre>

<h2 id="docker-network">Docker Network</h2>
<p>Información oficial -&gt; <a href="https://docs.docker.com/network/">aquí</a></p>
<pre><code class="bash">docker network &lt;command&gt;
</code></pre>

<p>Tipos de driver de redes:</p>
<ul>
<li><code>bridge</code> -&gt; Red por defecto en los contenedores.</li>
<li>Todos los contenedores de un mismo host están (en principio) conectados a esta red.</li>
<li>Pueden comunicarse entre ellos, hacerse ping, etc.</li>
<li><code>host</code> -&gt; Es la red del propio Docker Host.</li>
<li><code>none</code> -&gt; Es para crear contenedor sin red.</li>
<li><code>overlay</code> -&gt; Para conectar distintos docker daemons y permitir a docker Swarm hablar con ellos.</li>
<li><code>macvlan</code> -&gt; Permite asignar una mac a un contenedor.</li>
<li>Network Plugins -&gt; <a href="https://docs.docker.com/engine/extend/plugins_services/#network-plugins">aquí</a></li>
</ul>
<h3 id="crear-eliminar-red">Crear / Eliminar red</h3>
<pre><code class="bash"># Crear
docker network create [-d bridge] [--subnet 172.17.10.0/24] [--gateway 172.17.10.1] [--ip 172.17.10.50] &lt;red&gt;
# Eliminar
docker network rm &lt;red&gt; [&lt;red2&gt; &lt;red3&gt; ...]
</code></pre>

<h3 id="inspeccionar-red">Inspeccionar red</h3>
<pre><code class="bash">docker inspect &lt;red&gt;
</code></pre>

<h3 id="crear-un-contenedor-conectado-a-una-red-definida">Crear un contenedor conectado a una red definida</h3>
<pre><code class="bash">docker run --network &lt;red&gt; ...
</code></pre>

<p>Todos los contenedores que esten dentro de una red definida, a la hora de hacer un ping por ejemplo, no necesito poner su ip, con poner su nombre es suficiente (ya que tengo un DNS propio). Esto solo se puede hacer cuando es una red creada por mi, no en la red por defecto de docker.</p>
<h3 id="conectar-desconectar-un-contenedor-a-una-red-definida">Conectar / desconectar un contenedor a una red definida</h3>
<pre><code class="bash"># Conectar
docker network connect [&lt;opciones&gt;] &lt;red&gt; &lt;contenedor&gt;
# Desconectar
docker network disconnect [&lt;opciones&gt;] &lt;red&gt; &lt;contenedor&gt;
</code></pre>

<h2 id="docker-compose">Docker Compose</h2>
<p>Información oficial -&gt; <a href="https://docs.docker.com/compose/">aquí</a></p>
<p>Es para aplicaciones multicontenedor.<br />
La nomenclatura que se sigue a la hora de nombrar el fichero es <code>docker-compose-&lt;nombre&gt;.yml</code>, y su formato es <code>YAML</code>.</p>
<h3 id="instalacion-de-docker-compose">Instalación de Docker Compose</h3>
<p>Información oficial -&gt; <a href="https://docs.docker.com/compose/install/">aquí</a></p>
<pre><code class="bash">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
</code></pre>

<h3 id="docker-compose-up-levantar-contenedores-con-docker-compose">docker-compose up -&gt; Levantar contenedores con docker-compose</h3>
<p>Con este comando lanza docker-compose y ejecuta el fichero por defecto <code>docker-compose.yml</code></p>
<pre><code class="bash">docker-compose [-p &lt;nombre-proyecto&gt;] up [-d]
</code></pre>

<p>Si queremos que levante un fichero docker-compose especifico, hacemos</p>
<pre><code class="bash">docker-compose [-p &lt;nombre-proyecto&gt;] -f &lt;fichero-docker-compose&gt; up [-d]
</code></pre>

<h3 id="docker-compose-down-parar-y-eliminar-todo-lo-que-ha-hecho-docker-compose">docker-compose down -&gt; Parar y eliminar todo lo que ha hecho docker-compose</h3>
<pre><code class="bash">docker-compose [-f &lt;fichero-docker-compose&gt;] down [-d]
</code></pre>

<h3 id="estructura">Estructura</h3>
<p>Tiene cuatro secciones:</p>
<ul>
<li>version -&gt; Indica la version de Docker-Compose que se va a usar (poner <code>'3'</code> a menos que).</li>
<li>Es OBLIGATORIA</li>
<li>services -&gt; Son los distintos servicios / contenedores que se van a crear</li>
<li>Es OBLIGATORIA</li>
<li>volumes -&gt; opcional</li>
<li>networks -&gt; opcional</li>
</ul>
<pre><code class="yml">version:
services:
volumes:
networks:
</code></pre>

<p>Un ejemplo con un contenedor de nginx. Si fuera por comandos haríamos</p>
<pre><code class="bash">docker run -d --name nginx nginx
</code></pre>

<p>Con docker-compose</p>
<pre><code class="yml">version: '3'
services:
  web:
    container_name: nginx1
    ports:
      - &quot;8080:80&quot;
    image: nginx
</code></pre>

<p>Y para lanzarlo</p>
<pre><code class="bash">docker-compose up -d
</code></pre>

<p>Para eliminar todo lo que ha hecho el anterior fichero hacemos</p>
<pre><code class="bash">docker-compose down
</code></pre>

<h3 id="services">services</h3>
<ul>
<li><code>container_name</code> -&gt; Nombre del contenedor</li>
<li><code>image</code> -&gt; Imagen con la que se va a crear</li>
<li><code>build</code> -&gt; Ruta hasta el <code>Dockerfile</code> usar una imagen propia</li>
<li>
<p>Versión corta</p>
<p><code>yml
version: '3'
services:
  web:
    build: .</code></p>
</li>
<li>
<p>Versión extendida</p>
<p><code>yml
version: '3'
services:
webapp:
    build:
    context: ./dir
    dockerfile: mi-dockerfile
    args:
        buildno: 1</code></p>
</li>
<li>
<p><code>command</code> -&gt; Mandarle un comando, sobreescribiendo el del <code>Dockerfile</code> (si lo hubiera).</p>
</li>
<li><code>ports</code> -&gt; Exponer los puertos</li>
<li><code>restart</code> -&gt; Política de reinicio (información <a href="https://docs.docker.com/config/containers/start-containers-automatically/">aquí</a>)</li>
<li><code>no</code> -&gt; Por defecto.</li>
<li><code>on-failure</code> -&gt; Reiniciar el contenedor si hay un error.</li>
<li><code>always</code> -&gt; Reiniciar si el contenedor se para (si se ha parado a mano, se reiniciará cuando se reinicie el demonio de docker).</li>
<li><code>unless-stopped</code> -&gt; Parecido a <code>always</code> pero no se reinicia cuando se reinicia el demonio de docker.</li>
</ul>
<h3 id="volumes">volumes</h3>
<pre><code class="yml">version: &quot;3.2&quot;
services:
  web:
    image: nginx:alpine
    volumes:
      - type: volume
        source: mydata
        target: /data
        volume:
          nocopy: true
      - type: bind
        source: ./static
        target: /opt/app/static

  db:
    image: postgres:latest
    volumes:
      - &quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;
      - &quot;dbdata:/var/lib/postgresql/data&quot;

volumes:
  mydata:
  dbdata:
</code></pre>

<h3 id="networks">networks</h3>
<pre><code class="yml">version: '3'
services:
  web:
    networks:
     - some-network
     - other-network
networks:
  some-network:
  other-network:
</code></pre>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>